# ruby1004

Fait par samir
Exercice RUBY du 10/04

Premiers programmes
Maintenant que tu sais lancer un programme en Ruby, et que tu as des bases en Ruby, on va te demander de faire des programmes qui vont te permettre de mettre en pratique tes connaissances en code. Ces programmes peuvent para√Ætre abstraits, mais il est indispensable de ma√Ætriser ses boucles, arrays, etc avant de continuer pour faire des trucs un peu plus funky.

Ces programmes ne sont pas sens√©s √™tre faciles, et cette journ√©e sera l'une des plus intenses intellectuellement de la formation. Si tu gal√®res, ne t'en fais pas : c'est normal. Le fait de transpirer sur ce type de projets est indispensable pour que la suite de la formation se passe √† merveille. Le jeu en vaut la chandelle üòâ

Important : nous allons effectuer du peer code review demain, donc pense √† mettre en ligne ton code sur Github. D'ailleurs, nous te conseillons de le faire pour tous la majorit√© des projets : c'est un excellent entra√Ænement pour le monde de l'entreprise.

1. Multiples de 3 et 5
C√©dric Villani a besoin d'aide pour son prochain prix Nobel de Math√©matiques. Il a besoin de r√©soudre le probl√®me suivant : Si on liste tous les entiers naturels en dessous de 10 qui sont multiples de 3 ou 5, on obtient 3, 5, 6, et 9. La somme de ces nombres est √©gale √† 23.
Trouve la somme des multiples de 3 et 5 inf√©rieurs √† 1000.

2. Chiffrer des donn√©es
Apr√®s ce petit tour de chauffe, tu vas apprendre la cyber-s√©curit√©, avec un algorithme de chiffrement hyper secure (lol) : le chiffrement par d√©calage. En effet, la NSA a besoin de chiffrer leurs emails et veulent faire appel √† toi pour faire un chiffrement par d√©calage.

En cryptographie, le chiffrement par d√©calage, aussi connu comme le chiffre de C√©sar ou le code de C√©sar (voir les diff√©rents noms), est une m√©thode de chiffrement tr√®s simple utilis√©e par Jules C√©sar dans ses correspondances secr√®tes (ce qui explique le nom ¬´ chiffre de C√©sar ¬ª). Le texte chiffr√© s'obtient en rempla√ßant chaque lettre du texte clair original par une lettre √† distance fixe, toujours du m√™me c√¥t√©, dans l'ordre de l'alphabet. Pour les derni√®res lettres (dans le cas d'un d√©calage √† droite), on reprend au d√©but. Par exemple avec un d√©calage de 3 vers la droite, A est remplac√© par D, B devient E, et ainsi jusqu'√† W qui devient Z, puis X devient A etc. Il s'agit d'une permutation circulaire de l'alphabet. La longueur du d√©calage, 3 dans l'exemple √©voqu√©, constitue la cl√© du chiffrement qu'il suffit de transmettre au destinataire ‚Äî s'il sait d√©j√† qu'il s'agit d'un chiffrement de C√©sar ‚Äî pour que celui-ci puisse d√©chiffrer le message. Dans le cas de l'alphabet latin, le chiffre de C√©sar n'a que 26 cl√©s possibles (y compris la cl√© nulle, qui ne modifie pas le texte).

Ta mission : cr√©√©r une m√©thode chiffre_de_cesar qui prend en param√®tre un string et le nombre de lettre √† d√©caler, et sort le string modifi√©.

> chiffre_de_cesar("What a string!", 5)
=> "Bmfy f xywnsl!"
Tips :

Tu vas devoir utiliser l'ASCII
n'oublie pas de boucler z √† a
nous te conseillons de garder la m√™me casse
3. Stock picker
Apr√®s la cyber-s√©curit√© √† la NSA, Lehman Brother veut te d√©baucher pour faire de la finance. Hyper cool. Ils vont te demander de coder un premier programme qui permet, √† partir d'une array de prix, de connaitre le meilleur jour d'achat, le meilleur jour de revente pour faire le maximum de b√©n√©fices.
Voici par exemple une array de prix : [17,3,6,9,15,8,6,1,10], la fonction trader_du_dimanche va devoir sortir les index du jour d'achat et du jour de revente qui donneront le plus haut b√©n√©fice. Pour l'array vue ci-haut par exemple, ce sera le deuxi√®me jour (√† l'achat) et le cinqui√®me jour (√† la revente)

> trader_du_dimanche([17,3,6,9,15,8,6,1,10])
=> [1,4]  # $15 - $3 == $12
LVL UP Lehman Brothers sont tr√®s fiers de ton travail. Ils veulent maintenant te faire travailler sur plusieurs entreprises √† la fois. Ils vont te filer les stocks sous un format hash chaque jour, et tu devras trouver les meilleurs moments pour acheter et vendre des actions de chaque entreprise. Voici un exemple avec quelques jours :

jour_1 = { :GOO => 15, :MMM => 14, :ADBE => 12, :EA=> 13, :BA => 8, :KO => 10, :XOM => 20, :GPS => 7, :MCD => 11, DIS => 15, :CRM => 6, :JNJ => 10 }
jour_2 = { :GOO => 8, :MMM => 20, :ADBE => 3, :EA=> 10, :BA => 5, :KO => 19, :XOM => 12, :GPS => 6, :MCD => 15, DIS => 9, :CRM => 10, :JNJ => 17 }
jour_3 = { :GOO => 3, :MMM => 8, :ADBE => 15, :EA=> 5, :BA => 10, :KO => 5, :XOM => 15, :GPS => 13, :MCD => 10, DIS => 18, :CRM => 5, :JNJ => 14 }
jour_4 = { :GOO => 17, :MMM => 3, :ADBE => 6, :EA=> 9, :BA => 15, :KO => 6, :XOM => 8, :GPS => 1, :MCD => 10, DIS => 15, :CRM => 18, :JNJ => 3 }
jour_5 = { :GOO => 8, :MMM => 18, :ADBE => 4, :EA=> 6, :BA => 15, :KO => 18, :XOM => 3, :GPS => 12, :MCD => 19, DIS => 3, :CRM => 7, :JNJ => 9 }
jour_6 = { :GOO => 10, :MMM => 12, :ADBE => 8, :EA=> 3, :BA => 18, :KO => 20, :XOM => 5, :GPS => 11, :MCD => 3, DIS => 9, :CRM => 8, :JNJ => 15 }
jour_7 = { :GOO => 17, :MMM => 14, :ADBE => 2, :EA=> 17, :BA => 7, :KO => 13, :XOM => 1, :GPS => 15, :MCD => 15, DIS => 10, :CRM => 9, :JNJ => 17 }
Fais une fonction trader_du_lundi qui prend en entr√©e une array de hash contenant des prix d'action, et qui sort pour chaque entreprise le meilleur moment pour acheter, et le meilleur moment pour vendre.

4. Compter les mots
Apr√®s Lehman Brothers, Google a besoin de toi pour faire de la Data Science. Quelle star ! √âcris une fonction intitul√©e jean_michel_data qui prend en param√®tre 2 data types :

le corpus, un string dans lequel tu devras checker le nombre d'occurence de diff√©rents strings
le dictionnaire, une array de mots pour qui tu vas compter les occurences dans le corpus
La fonction te sortira le nombre d'occurence des mots du dictionnaire dans le corpus. Ainsi :

> dictionary = ["below", "down", "go", "going", "horn", "how", "howdy", "it", "i", "low", "own", "part", "partner", "sit"]
> jean_michel_data("below", dictionary)
=> {"below"=>1, "low"=>1}
> jean_michel_data("Howdy partner, sit down! How's it going?", dictionary)
=> {"down"=>1, "how"=>2, "howdy"=>1,"go"=>1, "going"=>1, "it"=>2, "i"=> 3, "own"=>1,"part"=>1,"partner"=>1,"sit"=>1}
4.bis Compter les mots (bis)
Google veut savoir combien de fois l'on peut trouver dans l'oeuvre int√©grale de Shakespeare les mots suivants :

dictionnary = ["the", "of", "and", "to", "a", "in", "for", "is", "on", "that", "by", "this", "with", "i", "you", "it", "not", "or", "be", "are"]
Cr√©√© un fichier shakespeare.txt qui reprend le corpus int√©gral de l'oeuvre de l'√©crivain anglais. Ton programme va appeler le fichier shakespeare.txt (indice : c'est plus facile s'ils sont dans le m√™me dossier), pour ensuite compter les occurences du dictionnaire.

Apr√®s les mots communs, Google sont curieux, et veulent savoir combien il y a de gros mots dans l'oeuvre de Shakeaspeare, pour voir si l'auteur anglais √©tait un coquin. Voici une liste de gros mots au format .txt. T√©l√©charge ce fichier, mets-le √† c√¥t√© de Shakespeare.txt, et trouve un moyen de transformer cette liste de mot au format txt en une array qui contient les mots convertits en string.


